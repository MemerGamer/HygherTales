#!/usr/bin/env bun
/**
 * Build the proxy as a standalone executable (sidecar binary) for Tauri.
 * 
 * Usage:
 *   bun run build-sidecar.ts --target=linux|windows|macos
 * 
 * Environment variables:
 *   CURSEFORGE_API_KEY - Required. Will be embedded in the binary.
 */

import { existsSync, mkdirSync, writeFileSync } from "fs";
import { join } from "path";
import { parseArgs } from "util";

// Parse command line arguments
const { values } = parseArgs({
  args: process.argv.slice(2),
  options: {
    target: {
      type: "string",
      short: "t",
    },
  },
});

const target = values.target;
if (!target || !["linux", "windows", "macos"].includes(target)) {
  console.error("Error: --target must be one of: linux, windows, macos");
  console.error("Usage: bun run build-sidecar.ts --target=linux|windows|macos");
  process.exit(1);
}

// Check for API key
const apiKey = process.env.CURSEFORGE_API_KEY;
if (!apiKey || apiKey.trim() === "") {
  console.error("Error: CURSEFORGE_API_KEY environment variable is required");
  console.error("Set it before running this script:");
  console.error("  export CURSEFORGE_API_KEY=your_key_here");
  process.exit(1);
}

console.log(`Building proxy sidecar for ${target}...`);
console.log(`API key length: ${apiKey.length} characters`);

// Map target to Bun compile target
// macOS: use arm64 (aarch64) - GitHub macos-latest runners are Apple Silicon
const bunTargetMap: Record<string, string> = {
  linux: "bun-linux-x64",
  windows: "bun-windows-x64",
  macos: "bun-darwin-arm64",
};

// Map target to Tauri's expected binary name suffix
const tauriSuffixMap: Record<string, string> = {
  linux: "x86_64-unknown-linux-gnu",
  windows: "x86_64-pc-windows-msvc.exe",
  macos: "aarch64-apple-darwin",
};

const bunTarget = bunTargetMap[target];
const tauriSuffix = tauriSuffixMap[target];
const outputName = `hyghertales-proxy-${tauriSuffix}`;

// Output directory
const binariesDir = join(import.meta.dir, "..", "desktop", "src-tauri", "binaries");
if (!existsSync(binariesDir)) {
  mkdirSync(binariesDir, { recursive: true });
  console.log(`Created binaries directory: ${binariesDir}`);
}

const outputPath = join(binariesDir, outputName);

// Create a temporary embedded env file that will be bundled
const embeddedEnvPath = join(import.meta.dir, "src", ".embedded-env.ts");
const embeddedEnvContent = `// Auto-generated by build-sidecar.ts - DO NOT EDIT
// This file is embedded into the compiled binary
export const EMBEDDED_CURSEFORGE_API_KEY = ${JSON.stringify(apiKey)};
`;

writeFileSync(embeddedEnvPath, embeddedEnvContent, "utf-8");
console.log(`Created embedded env file: ${embeddedEnvPath}`);

// Build command
const entryPoint = join(import.meta.dir, "src", "index.ts");

console.log(`Compiling ${entryPoint} to ${outputPath}...`);
console.log(`Bun target: ${bunTarget}`);

// Build args: --windows-hide-console so the sidecar does not open a console window on Windows
const buildArgs = [
  "bun",
  "build",
  entryPoint,
  "--compile",
  "--target",
  bunTarget,
  "--outfile",
  outputPath,
];
if (target === "windows") {
  buildArgs.push("--windows-hide-console");
}

const buildProcess = Bun.spawn(buildArgs, {
  stdout: "inherit",
  stderr: "inherit",
  cwd: import.meta.dir,
});

const exitCode = await buildProcess.exited;

if (exitCode === 0) {
  console.log(`✓ Successfully built sidecar binary: ${outputPath}`);
  
  // On Linux/macOS, make it executable
  if (target !== "windows") {
    try {
      Bun.spawnSync(["chmod", "+x", outputPath]);
      console.log(`✓ Made binary executable`);
    } catch (err) {
      console.warn(`Warning: Failed to chmod +x: ${err}`);
    }
  }
} else {
  console.error(`✗ Build failed with exit code ${exitCode}`);
  process.exit(exitCode);
}
